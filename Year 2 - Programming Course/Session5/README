I set myself the following tasks (inspired from the ideas in the tutorial and slightly changed by me).

First, I stole the code from the worked solution on the course website. Then I used it to compare the Euler and the Leapfrog method with different time steps. What I found out was that the Leapfrog method works much better and produces the expected orbits even at very large time steps, while the Euler method has problems and could even produce wrong answers if the time step is not sufficiently small. This is why I chose to work with the Leapfrog method in my following simulations. Still I have not deleted the implementation of the Euler method, so that you can see that I have used it.

My first simulation is of five particles which have similar initial conditions and differ only in the direction of their velocity vectors. This can also be thought of as approximation of an explosion in which something blows up into five identical pieces going with the same speed but in different directions. In order to make the simulation more interesting I decided to have the directions of the velocity vectors chosen randomly at every start of the program. This is what the RandomVelocityDirection function does. The simulation is produced by the function CollectionParticles. It takes as arguments the shared initial conditions of the particles. Then it initializes the five particles, giving them random velocity directions, and applies the Leapfrog method to calculate their trajectories. The output is written in five different files (one for each particle) which can be used afterwards to create gnuplot graphs. To achieve this I had to change the ShowState and LeapfrogDynamics functions so that they can write into files. The new functions are called fileState and LeapfrogToFile.

My second simulation is again of five particles, going in circular orbits, with identical initial conditions but this time we perturb their orbits at the beginning by little kicks of momentum in 5 different directions and observe the differences in their new trajectories. For this purpose I created a function makeCircular which looks at the position of a particle and according to that position changes its velocity, so that the orbit of the particle becomes circular. I have used Newton's laws of motion to derive the formulas for the velocity components in terms of the position components. This simulation is produced by the function CollectionParticles2. It takes as arguments the initial conditions of the particles and the magnitude of the momentum of a kick 'dp'. Then it initializes the particles in their circular orbits and then changes the components of the momentum of each particle in different ways using 'dp'. As a result the particles do not follow circular orbits. The function applies the Leapfrog method to calculate their trajectories and as we expect the orbits become less circular with the increasing power of the kicks. They also differ in respect to the direction of the kick (again as expected). The output is again written in five different files which can be used to create gnuplot graphs later.

I also created a gnuplot command file to plot the data from the output files of my simulations. I learned a lot programming while I was creating different functions for my simulations. I played a lot with different initial conditions which helped me learn a lot about the motion of particles in orbits as well.

My solution was in a file called MyPlanet.cc and the gnuplot commands were in a file called myGnu.
